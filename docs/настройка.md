# Настройка
## Командная настройка
Nesca4 является *консольной* программой, поэтому для настройки как и большинство подобных использует
аргументы, их еще называют флаги.

Все флаги идентифицируются если перед их ключевым словом стоит
минус ( **-** ), например, `noping` не флаг, а `-noping` флаг. Также, обычно принято, что для коротких флагов, (*у которых ключевое слово это только одна буква*), используется
один минуc, например, `-a`, `-V`; а для длинных, (*у которых ключевое слово больше одной буквы*), используется два минуса, например, `--db`, `--host`. Но, в nesca4 для удобства
все флаги начинаются только с одного минуса (`-noping`, `-v`, и т.д).

Также, некоторые флаги могут иметь параметр, в этом контексте, это какое либо значение которое передается вместе с флагом. Например, `-pingitme 10ms`,
тут параметром для флага `-pingtime` выступает `10ms`; а вот тут например, `-srcport 80`, параметр для флага `-srcport` это `80`. Вообщем,
флаги (*с параметрами и без*) в nesca4 имеют такой синтаксис:
```
  -флаг параметр
  -флаг
```

Чтобы использовать флаг нужно попросту записать его в команду для запуска программы, например, 

```
sudo ./nesca4 -printargs
```

таким образом мы запускаем nesca4, и активируем опцию printargs через флаг `-printargs`, (*этот флаг не имеет параметра поэтому мы его не указываем*).

Кроме того, понятное дело, можно указать сразу два или больше флагов, например,

```
sudo ./nesca4 -random-ip 100 -noscan -speed 5
```

тут используется три флага, два с параметрами, один без.

#### Справочное меню
Чтобы понять какие есть флаги, что они делают, и имеют ли они параметры, можно открыть так называемый `usage`, для этого можно совершить *холостой* запуск nesca4: 

```
sudo ./nesca4
```
Или запуск nesca4 с флагом `-help`:
```
sudo ./nesca4 -help
```
Структура этого меню выглядет так, (*позаимствована с nmap*):
```
КАТЕГОРИЯ
  -флаг <параметр>, ...,: описание
  ...,
````

#### Проверка опций
Чтобы проверить какие опции включены и какие они имееют значения, вы можете вызвать nesca4 с флагом `-printargs`:
```
sudo ./nesca4 -printargs
```
Выглядеть оно будет следующем образом:
```
-флаг=значение (статус активности)
```
В качестве статуса активности выступают константы `true` и `false`, и означают (`true = включено` а `false = выключено`),
подробнее о них мы поговорим в файловой настройке, если конечно это действительно требуется.


## Файловая настройка
Помимо прямой настройки (*с запуска*) используя флаги, nesca4 подерживает и файлы конфигурации (*конфиги*).
Стандартный конфиг nesca4 имеет следующий путь (`templates/default.cfg`), он подключается по умолчанию, и его при желании можно менять. Если требуется
подключить другой конфиг, то можно использовать флаг `-cfg`, указав в его параметр путь к подключаемому конфигу, например,
```
sudo ./nesca4 -cfg templates/verbose.cfg
```
Также, конфиги могут иметь абсолютно любое разширение файлов, (*даже никакое*), но я обычно использую `.cfg`.

### Строение конфига
Синтаксис конфигов таков:
```
[название_опции] = значение;
```
Название опции такое же как и название флага этой опции, например, опция которую репрезентирует флаг `-noping`, в конфиге будет иметь название этого флага, то есть - `noping`.
```
(флаг)             -noping
(опция в конфиге)  [noping] = значение; 
```
В конце каждой строчки конфига обязательно должна стоять `;`, это дает возможность парсеру правильно читать конфиги такого стиля:
```
[название_опции] =     значение;  [название_опции]
=
значение
; [название_опции]
= значение;
```
А название опции обязательно должно быть в квадратных скобках `[]`, и присваивать ей значение можно только через `=`. В общем, используйте шаблон синтаксиса который был дан выше и 
вы не ошибетесь.

#### Опция без параметра
Если какая либо опция не имеет параметра, как в случае выше с (`noping`), то в качестве ее значения могут быть только две встроенные константы, это `false` или `true`, их можно записать и цифрами, либо `0` для `false`, либо `1` для `true`. 

Надеюсь понятно, что `true` переводится как *истина* и означает включено, а `false` обратное ей значение (*то есть ложь, или выключена*).
Например, что бы включить опцию `noping`, можно записать ее одним из этих двух вариантов:
```
(1 вариант) [noping] = true;
(2 вариант) [noping] = 1;
```

#### Опция с параметром
Если какая либо опция имеет параметр, то в качестве ее значения будет указыватся именно он, причем также как и если бы это был флаг. Например, использовать флаг `-p 80,443`, тоже самое что и такую опцию в конфиге:
```
[p] = 80,443;
```
Если опция имеет параметр, но вам не нужно ее активировать (*а установка параметра опции это уже ее активация*), то вы можете использовать в качестве ее значение встроенную константу `NULL`, это даст понять парсеру что нужно
попросту пропустить эту строчку конфига.

#### Значения в ковычках
Если хотите, вы можете взять значение в двойные ковычки (`"`), в большинстве случаев это ни на что не повлияет, ведь ковычки попросту говорят парсеру учитывать
пробелы того что в этих ковычках. Так что, если в названии опции или значении, что мало вероятно, нужно будет учитывать пробелы, то запишите его в ковычках. 
```
(Можно так)   [services] = home/drocher228/ss;
(Можно и так) [services] = "home/drocher228/ss";
```

#### Порядок выполнения
Стоит помнить, что парсер работает построчно, и если опция повторяется два или больше раз, то именно последняя будет установлена, например,
```
[p] = 80;
[p] = 443;
[p] = 999;
[p] = 3;
```
В данном случае `p` установится именно в `3`, поскольку это последняя ее установка.

#### Препроцессор
Если нужно подключить, (*а точнее включить*) один конфиг в другой, или создать что то вроде переменной прямо в конфиге, то можно использовать перепроцессор. Его суть в том что он выполняется до парсинга. В nesca4 он насчитывает две директивы, (*директивой называется команда препроцессора*), первая для включения файла `include`, а вторая для создания макроса `define`.

Первая имеет следующий синтаксис:
```
#include (путь_к_файлу);
```
Вторая имеет следующий синтаксис:
```
#define (название_макроса) (значение);
```
#### Директива include
Для начала рассмотрим директиву `include`, которая переводится как "*включить*" и также как и для второй ее идея была позаимствована из Си. Итак.

Представим что это файл `1.cfg`:
```
[noping] = true;
```

Представим что это файл `2.cfg`:
```
#include (1.cfg);
[srcport] = 80;
```

После препроцессора `2.cfg` будет выглядеть следующем образом, (*именно такой результат увидит парсер*):
```
[noping] = true;
[srcport] = 80;
```
То есть, заместо `#include (1.cfg);` препроцессор подставил содержание файла `1.cfg`, именно таким образом работает директива `include`. Более того,
она работает рекурсивно, например представим такие файлы:

`4.cfg`: `[noping] = false;`  
`3.cfg`: `#include <4.cfg>`  
`2.cfg`: `#include <3.cfg>`  
`1.cfg`: `#include <2.cfg>`  

Для парсера файл `1.cfg` будет выглядеть так:
```
[noping] = false;
```
То есть препроцессор выполняет директиву `include` даже из включаемого файла другой `include`.

#### Директива define
Переводится как "*определить*", и позволяет создать макрос, это что то вроде перменной но в отличии от последней его нельзя менять. Итак, рассмотрим такой файл `kek.cfg`:
```
#define (NNNNN) (80);

[srcport]  = NNNNN;
[p]        = NNNNN;
```
Для парсера этот файл будет выглядеть следующем образом:
```
[srcport]  = 80;
[p]        = 80;
```
То есть, мы создали макрос с именем `NNNNN`, и привязали к этому имени значение `80`, так что, можно сказать что `NNNNN` это теперь ключевое слово
которое хранит значение `80`. И препроцессор при каждой встречи этого ключевого слова заменит его на значение которое оно хранит, то есть `80`. (*Понятное дело что макрос должен быть определен до своего использования*).

Более того, в макросы можно засунуть вообще любое значение, например:
```
#define (MY_MACROS) ([srcport]  = 80;);
MY_MACROS
```
Парсер увидит это так:
```
[srcport]  = 80;
```
Также ничего не мешает засунуть один макрос в другой:
```
#define (NUMBER)     (80);
#define (KEYWORD)    (srcport);
#define (END)        (;);

#define (MY_MACROS) ([KEYWORD]=NUMBER""END);

MY_MACROS
```
Парсер увидит вот так:
```
[srcport]  = 80;
```
Правда говоря мне для разделения одного макроса от другого приходится использовать здесь `""`, однако, врятли создавать макросы для `;` действительно кому то понадобится.

#### Комментарии
Коментарии позволяют утвердить текст (текстом я называю любой набор символов) который не будет подвергаться не парсингу не препроцессингу. Их можно использовать, например, для временной диактивации строчки или каких либо заметок.

Для утверждения комментария используется символ `$`, все что после него будет считаться комментарием, например:
```
$ Сервисы 8489384930834905
[services] = "home/drocher228/ss";        $ Сервисы 22822
$       jkfgdjsl
```
Все комментарии будут удалены еще перед парсером, и препроцессором.
